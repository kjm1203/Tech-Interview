# 5. 자료구조

## 5.1 복잡도

복잡도는 **시간 복잡도(Time Complexity)** 와 **공간 복잡도(Space Complexity)** 로 나뉘며,  
알고리즘의 효율성을 평가하는 기준이다.  

- **시간 복잡도:** 알고리즘이 실행되는 데 걸리는 시간  
- **공간 복잡도:** 프로그램이 사용하는 메모리의 양  

---

### 5.1.1 시간 복잡도

시간 복잡도는 입력 크기 `n`이 증가할 때 알고리즘 수행 시간이 어떻게 변하는지를 나타낸다.  
보통 **빅오(Big-O) 표기법**으로 표현한다.

#### 대표적인 시간 복잡도

| 표기 | 이름 | 설명 | 예시 |
|------|------|------|------|
| O(1) | 상수 시간 | 입력 크기와 관계없이 일정한 시간 | 배열의 인덱스 접근 |
| O(log n) | 로그 시간 | 탐색, 이진 트리 탐색 | 이진 탐색(Binary Search) |
| O(n) | 선형 시간 | 입력 크기에 비례 | 단순 순회 |
| O(n log n) | 로그 선형 시간 | 효율적 정렬 | 병합 정렬, 퀵 정렬 |
| O(n²) | 이차 시간 | 중첩 반복문 | 버블 정렬 |
| O(2ⁿ) | 지수 시간 | 조합 탐색, 백트래킹 | 부분집합 생성 |
| O(n!) | 팩토리얼 시간 | 모든 순열 탐색 | 순열 생성 |

> 입력 크기가 커질수록 **O(1) → O(log n) → O(n) → O(n²)** 순으로 성능이 급격히 저하된다.

<br>

#### 시간 복잡도 증가율 비교

아래 표는 입력 크기(n)가 커질 때 각 복잡도의 상대적 증가율을 나타낸다.

| 입력 크기 n | O(1) | O(log n) | O(n) | O(n log n) | O(n²) | O(2ⁿ) |
|--------------|-------|-----------|-------|-------------|--------|--------|
| 10 | 1 | 3 | 10 | 30 | 100 | 1,024 |
| 100 | 1 | 7 | 100 | 700 | 10,000 | 1.27×10³⁰ |
| 1,000 | 1 | 10 | 1,000 | 10,000 | 1,000,000 | 1.07×10³⁰¹ |

> 같은 입력이라도 복잡도 차이에 따라 연산량이 천문학적으로 달라진다.

<br>

#### 시간 복잡도의 속도 비교

| 복잡도 | 특징 | 증가율 | 효율성 |
|---------|------|---------|----------|
| O(1) | 입력 크기와 무관 | 일정 | 매우 빠름 |
| O(log n) | 로그 비율로 증가 | 완만 | 빠름 |
| O(n) | 입력 크기에 비례 | 선형 증가 | 보통 |
| O(n log n) | 정렬에 자주 등장 | 빠른 성장 | 중간 |
| O(n²) | 중첩 루프 구조 | 급격히 증가 | 느림 |
| O(2ⁿ), O(n!) | 조합/순열 탐색 | 폭발적 증가 | 매우 느림 |

> O(1) → O(log n) → O(n) → O(n²) → O(2ⁿ) 순으로 시간 효율이 떨어진다.

---

### 5.1.2 공간 복잡도

공간 복잡도는 프로그램 실행 중 **필요한 메모리의 양**을 의미한다.  
배열, 리스트, 재귀 호출 스택 등이 이에 포함된다.

```java
int[] a = new int[1004];
```

위 예시는 약 4KB의 공간을 사용하며,  
입력 크기 n이 커질수록 사용되는 **메모리량의 증가율**을 측정하는 것이 공간 복잡도이다.

---

### 5.1.3 자료구조에서의 시간 복잡도

시간 복잡도는 **효율적인 코드 설계**를 위해 필요하다.  
예를 들어 O(n²) 알고리즘은 1,000개의 데이터에 대해 약 1,000,000번의 연산이 필요하지만,  
O(n log n) 알고리즘으로 개선하면 약 10,000번으로 줄일 수 있다.

> 입력 크기가 커질수록 효율 차이는 기하급수적으로 커진다.

<br>

자료 구조마다 접근, 탐색, 삽입, 삭제의 복잡도가 다르다.  
다음 표는 대표적인 **평균 시간 복잡도**를 나타낸다.

#### 평균 시간 복잡도

| 자료 구조 | 접근 | 탐색 | 삽입 | 삭제 |
|------------|------|------|------|------|
| 배열(Array) | O(1) | O(n) | O(n) | O(n) |
| 스택(Stack) | O(n) | O(n) | O(1) | O(1) |
| 큐(Queue) | O(n) | O(n) | O(1) | O(1) |
| 이중 연결 리스트(Doubly Linked List) | O(n) | O(n) | O(1) | O(1) |
| 해시 맵(HashMap) | O(1) | O(1) | O(1) | O(1) |
| 이진 탐색 트리(BST) | O(log n) | O(log n) | O(log n) | O(log n) |
| AVL 트리 | O(log n) | O(log n) | O(log n) | O(log n) |
| 레드 블랙 트리(Red-Black Tree) | O(log n) | O(log n) | O(log n) | O(log n) |

<br>

#### 최악 시간 복잡도

| 자료 구조 | 접근 | 탐색 | 삽입 | 삭제 |
|------------|------|------|------|------|
| 배열(Array) | O(1) | O(n) | O(n) | O(n) |
| 스택(Stack) | O(n) | O(n) | O(1) | O(1) |
| 큐(Queue) | O(n) | O(n) | O(1) | O(1) |
| 이중 연결 리스트(Doubly Linked List) | O(n) | O(n) | O(1) | O(1) |
| 해시 맵(HashMap) | O(n) | O(n) | O(n) | O(n) |
| 이진 탐색 트리(BST) | O(n) | O(n) | O(n) | O(n) |
| AVL 트리 | O(log n) | O(log n) | O(log n) | O(log n) |
| 레드 블랙 트리(Red-Black Tree) | O(log n) | O(log n) | O(log n) | O(log n) |

> 일반적으로 O(1)인 해시 테이블이 가장 빠르지만, 공간 복잡도는 크다.  
> 해시(평균 O(1)) + 균형 트리(최악 방어 O(log n)) 조합이 안전하다.

---

### 핵심 요약

- **시간 복잡도**는 입력 크기 변화에 따른 실행 시간 증가율을 나타내는 지표이다.  
- **공간 복잡도**는 알고리즘/자료구조가 점유하는 메모리 증가율이며, 시간과 **트레이드오프** 관계가 있다.  
- 실무 기준으로 **정렬·탐색의 목표 복잡도**는 보통 `O(n log n)` 또는 그 이하이다.  
- 자료구조별 연산 복잡도가 다르므로, **문제의 접근/탐색/삽입/삭제 패턴**에 맞춰 구조를 선택해야 한다.  
- 해시맵은 빠르지만 공간 효율이 낮고, 트리는 안정적 성능을 보장한다.